[{"section":"Blog","slug":"/blog/linker/","title":"Linker","description":"","date":"December 9, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/linkerFile_hu5030353809623404206.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/linkerFile_hu8498057527119778811.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/linkerFile_hu3500763117210115635.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/linkerFile_hu6830389736987807122.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"notes","tags":"","content":"The linker file (or linker script) plays a crucial role in embedded systems development, defining how the program\u0026rsquo;s sections (like code, data, and stack) are placed in the memory map of the target device.\nMemory Section The memory section defined how the complete is split into parts and pieces.\nSections Section This section determines how different parts of the program (code, data, etc.) are allocated into the memory regions defined in the MEMORY section.\nGeneral Concepts Linker files are tailored to the target hardware and compiler toolchain. GCC uses GNU linker (ld) scripts.\nKeywords: . - Dot Symbol : The . symbol represents the current memory address. KEEP : Without KEEP, the linker might optimize away unused sections (e.g., .fingerprint) to reduce binary size.\nWhat is Reset Handler Address ? The reset Handler is the first piece of code that is executed after a system resets. The Reset Handler Address is the address where the system\u0026rsquo;s execution begins after the reset. This reset handler mainly handles the setting up of configuration.\nWhen a system resets, the processor first initializes the stack pointer to the value stored at the initial stack pointer address (typically located at the beginning of the vector table). Then, it loads the address of the Reset Handler from the Reset Vector, which is part of the vector table. The processor jumps to this address to start executing the Reset Handler.\nThe Reset Handler\u0026rsquo;s primary role is to set up the system configuration, such as initializing memory, setting up the system clock, and preparing the runtime environment before branching to the main application.\nWhat is a Vector Table Offset Register (VTOR) ? The Vector Table Offset Register (VTOR) is a special register in microcontrollers (like those based on ARM Cortex-M) that tells the processor where to find the vector table in memory.\nThe vector table contains addresses (pointers) to interrupt and exception handlers, including the Reset Handler. By changing the VTOR, you can relocate the vector table to a different memory location, which is useful for things like bootloaders or running multiple firmware versions.\nIn simple terms, the VTOR is like a signpost that points the processor to the start of the list of interrupt addresses.\nWhat is a vector table ? How do you know where is the start address ? Is it defined in the linker file ? The MCU looks at the ISP (Initial Stack Pointer) which is usually at 0x0000_0000. So whatever address is written at 0x0000_0000 is where the program will jump and then that is where the program will start. 0x0000_0004 is where the Reset Handler Address is stored. How do you jump from Bootloader to Application ? Disable interrupts. Deinitialize peripherals, timers, etc., that were used by the bootloader. Set the vector table offset (SCB-\u0026gt;VTOR) to point to the vector table of the application (like 0x50000). Update the Main Stack Pointer (MSP) to the initial stack pointer defined by the application. Jump to the application\u0026rsquo;s Reset_Handler (found at the application\u0026rsquo;s vector table at 0x50004). What is system control block ? Where can I find linker file for projects in STM32 ? "},{"section":"Blog","slug":"/blog/interrupts/","title":"Interrupts","description":"","date":"November 15, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/interruptsCover_hu14579437320101644231.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/interruptsCover_hu6016484751495926490.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/interruptsCover_hu17114845174765492160.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/interruptsCover_hu9434106646238053759.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"notes","tags":"","content":"What is an Interrupt? In an embedded system, an interrupt is a hardware or software signal that temporarily halts the normal execution of a program to service a higher-priority event.\nWhat is the functionality of ISR? The ISR’s job is to handle the specific event that caused the interrupt. This might involve:\nReading data from a peripheral (e.g., reading sensor data from an ADC). Clearing interrupt flags or status bits to acknowledge the interrupt and prevent continuous triggering. Performing any necessary calculations or data processing based on the received data. Potentially notifying other parts of the program about the event (using flags or queues). What is an Interrupt Handling Process? Interrupt Trigger Interrupt Request and Enabling Context Saving Interrupt Vector Table (IVT) Lookup ISR Execution ISR Actions Context Restore Return to Main Program\nWhat is IVT? The IVT acts like a phone book for interrupts, containing the memory addresses of all the ISRs (Interrupt Service Routines) for different interrupt sources.\nWhat is an Interrupt Priority? Many embedded systems allow assigning priority levels to interrupts. The IVT might be prioritized, or there might be separate priority registers. This ensures that critical events are handled first by higher-priority ISRs, even if lower-priority interrupts are pending.\nWhat is polling in MCU? How is polling different from Interrupts ? Both polling and interrupts are methods that allow a microcontroller (or any processor) to manage and respond to events (like button presses, sensor data, or incoming communication). The downside in Polling is that your program is constantly looping and using up CPU resources, even if nothing is happening. Interrupts are like setting up an alert system, so the processor only gets “interrupted” when something important happens.\nWhen to Use Each Polling is simpler to implement and can be used for situations where response time isn’t critical, and the program has only a few tasks. Interrupts are preferred in real-time systems where quick responses are essential, as they allow the microcontroller to react immediately to events. What is a handler for an IRQ ? In embedded systems, an IRQ (Interrupt Request) is a signal that tells the microcontroller to stop what it\u0026rsquo;s doing and handle something important, such as data from a sensor or a button press. When an IRQ occurs, the microcontroller pauses its current task and jumps to a special function called an Interrupt Handler (or Interrupt Service Routine, ISR).\nWhat is callback mechanism ? What is IRQ handler callback function ? How are callback functions involved in IRQ ? Does Enabling Interrupt mean activating an interrupt ? This involves configuring the hardware to generate an interrupt signal when a specific event occurs (e.g., a FIFO overflow in this case).\nActivating an Interrupt: Refers to the moment the interrupt condition occurs (e.g., FIFO overflow flag is set in the status register), which triggers the hardware to invoke the interrupt service routine (ISR). The interrupt won\u0026rsquo;t activate unless it\u0026rsquo;s enabled.\nFlexCAN_Ip_EnableInterrupts\nWhat is Nested Vector Interrupt Controller (NVIC) ? What is the difference between Interrupt and exception ? I do not understand how a program that is continouslly running a function suddenly stop and move to an interrupt ? What does it mean by \u0026ldquo;16 programmable priority levels\u0026rdquo; ? "},{"section":"Blog","slug":"/blog/canbus/","title":"CAN Bus for Developers","description":"","date":"November 15, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/canCover_hu2028609224953249982.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/canCover_hu390322945121766959.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/canCover_hu12327609060923200997.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/canCover_hu17545275120036112137.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"notes","tags":"","content":"This is a notes page for understanding the implementation of CAN Messages from the perspective of developers.\nHow does a CAN message frame look like ? What is CAN Message Filtering ? All messages on a CAN network will be received by all nodes. To process only messages of interest, a hardware filtering mechanism is implemented. The CAN Protocol module can be configured to receive only messages of interest. Each acceptance filter contains a filter object and a mask object. The user application configures the specific filter to receive a message with a given identifier by setting the filter object and mask object to match the identifier of the message to be received.\nWhat is the use of mask ? A mask are the bits that are used for comparing in order to filter CAN messages.\n! Add a chart of filter and mask.\nCan masking and filtering be applied to Tx so that messages are sent only to a particular node? How is the masking done in order to isolate the the bits ? ROADMAP OF CAN - PENDING What is the difference between CAN Base Frame and CAN Extended Frame ? What is the difference between Standard ID and Extended ID? In the standard frame format (also known as 2.0A), the length of the ID is 11 bits. In the extended frame format (also known as 2.0B), the length of the ID is 29 bits.\nBut why do we need two different length of ID\u0026rsquo;s ? The original CAN standard (2.0A) uses an 11-bit identifier, allowing for 2,048 unique message IDs. This shorter ID is more efficient because it reduces the size of the CAN frame, leaving more room for data payload and reducing transmission time, which is crucial in applications where timing and bandwidth efficiency are priorities (e.g., automotive systems).\nExtended Frame (29-bit ID): The extended CAN standard (2.0B) was introduced to support 8,388,608 unique message IDs. This allows for far more flexibility in larger or more complex systems, where more nodes and types of messages need to be distinguished. The trade-off is that the larger ID consumes more space in the frame, slightly reducing the data payload efficiency. The extended format was designed in such a way that it is backward compatible with the standard format, allowing mixed networks where both types of frames coexist.\nWhat is CAN IDs ? And what are Functional Request, Physical Request and Response CAN ID ? What is their purpose ? Is it possible to send timestamps in each CAN Message and how is it calculated? What are CAN buffers ? Transmit (TX) Buffers: These hold messages that are waiting to be sent onto the CAN bus. Receive (RX) Buffers: These store incoming messages received from the CAN bus.\nExample of Transmission Using Buffers The application code requests to send a message by writing data into a TX buffer. The CAN controller checks if the buffer is ready and assigns it a priority. The message waits in the TX buffer until the bus is free, at which point the controller begins transmitting. If a higher-priority message arrives while a lower-priority message is pending, the CAN controller may delay the lower-priority message, prioritizing the transmission of the higher-priority one.\nWhat if you are not using RxFIFO in CAN bus ? So you either configure each individual MB or you use RxFIFO.\nHow do I decide, how many message buffers must my module have ? What is CAN freeze mode and why is it needed ? As the name suggests, the CAN module in this goes into freeze mode and does not transmit or receive any CAN message. But retains its\nconfiguration and status. The main requirement of this mode would be when there is a firmware upgrade going, or during the initial startup of the system or to isolate a system from CAN Bus.\nIf not output hardware is connected, will all the messages be waiting in the TxBuffer ? And how can you access it for debugging purpose ? Are you exchanging data or are you exchanging message codes that are known to both sender and receiver ? Answer in terms of CAN and CAN FD. Answer in terms of UDS.\nWhy is a termination resistor needed in CAN Bus ? What is CAN ISO-TP ? What do you mean by flexible in CAN-FD ? "},{"section":"Blog","slug":"/blog/esp32parts/","title":"ESP32 Parts - Not the real one!","description":"","date":"September 30, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/esp32/esp32_one_hu13977591214653227673.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/esp32\\/esp32_one_hu13956684535262567727.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/esp32/esp32_one_hu6884920702742729729.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/esp32\\/esp32_one_hu14717393550346260043.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Components","tags":"","content":"And yet again, I decided to order components from AliExpress with the least hope of finding a real ESP32 by Espressif, but as expected it was an ESP32 looking clone. And it works ! As I just wanted to get started with some ESP32, I ordered ESP32-WROOM-32D which when I looked for datasheet found out was NRND (Not recommended for new design). I think it is okay to get started with this later upgrade to a original and recommended board.\nAs I was inspecting, looking at the various components on the board, I was a bit confused when comparing with the actual Espressif ESP32-WROOM-32D dev board. So I decided to make notes here for myself about various components and what they do.\nParts Espressif has all its document available open source for ESP32, so anyone can build the board for themselves. So as far as the board works good, I do not mind which alternatives are used. And it just costs 3.79€.\nESP-WROOM-32D: This is the brain of the ESP32 Board. WCH340C: USB to serial port converter chip. Schottky Diode: Schottky diodes are used as switches in fast-clamp diode applications. They help in help with efficient power handling and prevent potential damage from improper power connections. Boot Button: The BOOT button on the ESP32 is typically used to put the device into bootloader mode, allowing it to receive new firmware over a serial connection. En Button: The EN (enable) button resets the chip, restarting it and applying any changes made during the boot process. and many other SMD(Surface-mount technology). On a side note, soldering or desoldering an SMD is an art which I totally lack.\nHere are the specifications of the board:\nTest In order to test the ESP32, I followed the various instructions available online by using Arduino IDE to scan the WiFi Network and I was successful doing so.\nI also tried running the blink application using ESP-IDF and I was able to do that as well.\nNow is the time for me to further explore ESP32. On to the next blog.\nNote\nI\u0026rsquo;m still a beginner when it comes to these concepts, so my understanding might be off, but I’m confident I\u0026rsquo;ll improve over time. Feel free to reach out if you\u0026rsquo;d like to help by offering corrections.\n"},{"section":"Blog","slug":"/blog/wolfssltext/","title":"Encryption of Text file with wolfCrypt","description":"","date":"September 23, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/wolfSSLCover_hu5231295417995472875.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/wolfSSLCover_hu3003472458139720379.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/wolfSSLCover_hu5733191293348103817.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/wolfSSLCover_hu14733043352170037464.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Cryptography","tags":"","content":"Introduction: This tutorial guides you through installing and using wolfCrypt, a cryptographic library by wolfSSL, to encrypt a text file on a Windows machine. We\u0026rsquo;ll focus on the practical application rather than the underlying encryption and decryption mechanisms.\nPre-Requisites MSYS2 MINGW64 (https://www.msys2.org/) Eclipse IDE for Embedded C/C++ Developers Installation Download wolfSSL package from their website. https://www.wolfssl.com/download/ -\u0026gt; Download wolfssl-5.7.2.zip or any latest version. Extract the Archive: Extract the downloaded file to a directory of your choice. Navigate Using MSYS2 MINGW64: Open MSYS2 MINGW64 from your Start menu. Use the cd command to navigate to the folder where you extracted the downloaded archive (e.g., wolfssl-5.7.2). Here\u0026rsquo;s an example: cd C:/Programming/crypto/wolfssl-5.7.2 Compile and Install: Run the following commands in the MSYS2 MINGW64 terminal window: ./configure --enable-cryptonly make make install Explanation of the Commands:\n./configure --enable-cryptonly: This command configures the build process for wolfCrypt, enabling only the encryption functionalities. make: This command builds the wolfCrypt library. make install: This command installs the compiled library files to the appropriate system directories. Integration Now to itegrate the created wolfCrypt dynamic libraries to an Eclipse based C project, follow the below steps:\nCreate a New C/C++ Project: In Eclipse, select File \u0026gt; New \u0026gt; C/C++ Project. Choose the C Managed Build template, provide a project name like cryptTxt, select Empty Project, and choose MinGW GCC as the toolchain. Configure Project Properties: Right-click on the project, go to Properties, navigate to C/C++ Build \u0026gt; Settings, and in the Tool Settings tab under MinGW C Linker, go to Libraries. Library Search Path (-L): Add the directory containing the wolfCrypt DLL files. Libraries (-l): Add wolfssl to link against the wolfSSL library. Add Include Path: In the same Project Properties window, go to Paths and Symbols. Under GNU C, add the directory containing the wolfCrypt header files (e.g., C:\\msys64\\mingw64\\include). C:\\msys64\\mingw64\\include\\ Now the eclipse project is integrated with wolfCrypt.\nImplementation Create Files: Create a main.c file and an inputText.txt file within your project. Copy Code: Paste the relevant code from the specified Git repository into main.c. Build and Run: Right-click on the project, select Build Project, and then Run as Local C/C++ Program. This will encrypt the inputText.txt file and create an encrypted encrypted.txt file. Decrypt: To decrypt the file, modify line 5 of the code from #define ENCRYPT to #define DECRYPT. Rebuild and run again to create a decryptedTxt.txt file with the original data. Encryption Complete: The inputText.txt file has been successfully encrypted and saved as encrypted.txt.\nDecryption: To decrypt the encrypted file, follow these steps:\nModify the Code: In your main.c file, locate line 5 and change #define ENCRYPT to #define DECRYPT. This will switch the code from encryption mode to decryption mode. Rebuild and Run: Recompile the project and run it again. Check the Decrypted File: The decrypted data will be saved in a new file named decryptedTxt.txt. Open this file to verify that the original content has been restored. Info\nThis is a fundamental example of using wolfCrypt. wolfCrypt is designed for more complex applications, which we\u0026rsquo;ll explore in future blogs.\n"},{"section":"Blog","slug":"/blog/logicanalyzer/","title":"Logic Analyzer","description":"this is meta description","date":"September 22, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/logicAnalyzer/logicAnalyzer1_hu7605063706739470453.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/logicAnalyzer\\/logicAnalyzer1_hu1077896768915640660.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/logicAnalyzer/logicAnalyzer1_hu3765446253500243400.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/logicAnalyzer\\/logicAnalyzer1_hu3387212331286987241.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Components","tags":"component","content":"Introduction: As an embedded engineer, a reliable logic analyzer is an essential tool for debugging and troubleshooting projects. While options like the Kingst Logic Analyzer offer excellent performance, they can be quite expensive. In this post, I\u0026rsquo;ll share my experience with a budget-friendly clone that I found on Amazon.\nProduct After searching online for more affordable alternatives, I came across a CY7C68013A-56-based logic analyzer on Amazon. Despite its low price, it has performed surprisingly well in my personal projects.\u0026quot;\nOne of the biggest advantages of this clone is its compatibility with popular logic analyzer software like Salae. Even though Salae\u0026rsquo;s official hardware is significantly more expensive, the free software works seamlessly with this budget-friendly option.\nGetting Started Download and install the Salae software. Connect the logic analyzer to your computer using the provided USB cable. The software should automatically detect the device. Troubleshooting Tip If you encounter issues with device detection, try the following:\nUnplug the analyzer. Uninstall any unknown devices from your Device Manager. Plug the analyzer back in. The drivers will be installed automatically. Info\nI\u0026rsquo;m currently exploring whether this clone is compatible with other popular logic analyzer software like SigRock Pulseview. I\u0026rsquo;ll update this post with my findings.\nConclusion Overall, I\u0026rsquo;ve been very pleased with the performance of this budget-friendly logic analyzer. It\u0026rsquo;s a great option for those who need a reliable tool without breaking the bank. If you\u0026rsquo;re looking for a cost-effective solution for your embedded projects, I highly recommend giving this clone a try.\n"}]